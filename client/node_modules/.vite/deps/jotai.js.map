{
  "version": 3,
  "sources": ["../../jotai/esm/vanilla.mjs", "../../jotai/esm/react.mjs"],
  "sourcesContent": ["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst CONTINUE_PROMISE = Symbol(\n  (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" ? \"CONTINUE_PROMISE\" : \"\"\n);\nconst PENDING = \"pending\";\nconst FULFILLED = \"fulfilled\";\nconst REJECTED = \"rejected\";\nconst isContinuablePromise = (promise) => typeof promise === \"object\" && promise !== null && CONTINUE_PROMISE in promise;\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise, abort, complete) => {\n  if (!continuablePromiseMap.has(promise)) {\n    let continuePromise;\n    const p = new Promise((resolve, reject) => {\n      let curr = promise;\n      const onFulfilled = (me) => (v) => {\n        if (curr === me) {\n          p.status = FULFILLED;\n          p.value = v;\n          resolve(v);\n          complete();\n        }\n      };\n      const onRejected = (me) => (e) => {\n        if (curr === me) {\n          p.status = REJECTED;\n          p.reason = e;\n          reject(e);\n          complete();\n        }\n      };\n      promise.then(onFulfilled(promise), onRejected(promise));\n      continuePromise = (nextPromise, nextAbort) => {\n        if (nextPromise) {\n          continuablePromiseMap.set(nextPromise, p);\n          curr = nextPromise;\n          nextPromise.then(onFulfilled(nextPromise), onRejected(nextPromise));\n          abort();\n          abort = nextAbort;\n        }\n      };\n    });\n    p.status = PENDING;\n    p[CONTINUE_PROMISE] = continuePromise;\n    continuablePromiseMap.set(promise, p);\n  }\n  return continuablePromiseMap.get(promise);\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isAtomStateInitialized = (atomState) => \"v\" in atomState || \"e\" in atomState;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n};\nconst getPendingContinuablePromise = (atomState) => {\n  const value = atomState.v;\n  if (isContinuablePromise(value) && value.status === PENDING) {\n    return value;\n  }\n  return null;\n};\nconst addPendingContinuablePromiseToDependency = (atom, promise, dependencyAtomState) => {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    promise.then(\n      () => {\n        dependencyAtomState.p.delete(atom);\n      },\n      () => {\n        dependencyAtomState.p.delete(atom);\n      }\n    );\n  }\n};\nconst createPending = () => [/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set()];\nconst addPendingAtom = (pending, atom, atomState) => {\n  if (!pending[0].has(atom)) {\n    pending[0].set(atom, /* @__PURE__ */ new Set());\n  }\n  pending[1].set(atom, atomState);\n};\nconst addPendingDependent = (pending, atom, dependent) => {\n  const dependents = pending[0].get(atom);\n  if (dependents) {\n    dependents.add(dependent);\n  }\n};\nconst getPendingDependents = (pending, atom) => pending[0].get(atom);\nconst addPendingFunction = (pending, fn) => {\n  pending[2].add(fn);\n};\nconst flushPending = (pending) => {\n  while (pending[1].size || pending[2].size) {\n    pending[0].clear();\n    const atomStates = new Set(pending[1].values());\n    pending[1].clear();\n    const functions = new Set(pending[2]);\n    pending[2].clear();\n    atomStates.forEach((atomState) => {\n      var _a;\n      return (_a = atomState.m) == null ? void 0 : _a.l.forEach((l) => l());\n    });\n    functions.forEach((fn) => fn());\n  }\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  let debugMountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    debugMountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => {\n    let atomState = atomStateMap.get(atom);\n    if (!atomState) {\n      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n      atomStateMap.set(atom, atomState);\n    }\n    return atomState;\n  };\n  const setAtomStateValueOrPromise = (atom, atomState, valueOrPromise, abortPromise = () => {\n  }, completePromise = () => {\n  }) => {\n    const hasPrevValue = \"v\" in atomState;\n    const prevValue = atomState.v;\n    const pendingPromise = getPendingContinuablePromise(atomState);\n    if (isPromiseLike(valueOrPromise)) {\n      if (pendingPromise) {\n        if (pendingPromise !== valueOrPromise) {\n          pendingPromise[CONTINUE_PROMISE](valueOrPromise, abortPromise);\n          ++atomState.n;\n        }\n      } else {\n        const continuablePromise = createContinuablePromise(\n          valueOrPromise,\n          abortPromise,\n          completePromise\n        );\n        if (continuablePromise.status === PENDING) {\n          for (const a of atomState.d.keys()) {\n            const aState = getAtomState(a);\n            addPendingContinuablePromiseToDependency(\n              atom,\n              continuablePromise,\n              aState\n            );\n          }\n        }\n        atomState.v = continuablePromise;\n        delete atomState.e;\n      }\n    } else {\n      if (pendingPromise) {\n        pendingPromise[CONTINUE_PROMISE](\n          Promise.resolve(valueOrPromise),\n          abortPromise\n        );\n      }\n      atomState.v = valueOrPromise;\n      delete atomState.e;\n    }\n    if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n      ++atomState.n;\n    }\n  };\n  const addDependency = (pending, atom, a, aState) => {\n    var _a;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && a === atom) {\n      throw new Error(\"[Bug] atom cannot depend on itself\");\n    }\n    const atomState = getAtomState(atom);\n    atomState.d.set(a, aState.n);\n    const continuablePromise = getPendingContinuablePromise(atomState);\n    if (continuablePromise) {\n      addPendingContinuablePromiseToDependency(atom, continuablePromise, aState);\n    }\n    (_a = aState.m) == null ? void 0 : _a.t.add(atom);\n    if (pending) {\n      addPendingDependent(pending, a, atom);\n    }\n  };\n  const readAtomState = (pending, atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!(force == null ? void 0 : force(atom)) && isAtomStateInitialized(atomState)) {\n      if (atomState.m) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(\n        ([a, n]) => (\n          // Recursively, read the atom state of the dependency, and\n          // check if the atom epoch number is unchanged\n          readAtomState(pending, a, force).n === n\n        )\n      )) {\n        return atomState;\n      }\n    }\n    atomState.d.clear();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (!isAtomStateInitialized(aState2)) {\n          if (hasInitialValue(a)) {\n            setAtomStateValueOrPromise(a, aState2, a.init);\n          } else {\n            throw new Error(\"no atom init\");\n          }\n        }\n        return returnAtomValue(aState2);\n      }\n      const aState = readAtomState(pending, a, force);\n      if (isSync) {\n        addDependency(pending, atom, a, aState);\n      } else {\n        const pending2 = createPending();\n        addDependency(pending2, atom, a, aState);\n        mountDependencies(pending2, atom, atomState);\n        flushPending(pending2);\n      }\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      setAtomStateValueOrPromise(\n        atom,\n        atomState,\n        valueOrPromise,\n        () => controller == null ? void 0 : controller.abort(),\n        () => {\n          if (atomState.m) {\n            const pending2 = createPending();\n            mountDependencies(pending2, atom, atomState);\n            flushPending(pending2);\n          }\n        }\n      );\n      return atomState;\n    } catch (error) {\n      delete atomState.v;\n      atomState.e = error;\n      ++atomState.n;\n      return atomState;\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(void 0, atom));\n  const recomputeDependents = (pending, atom) => {\n    const getDependents = (a) => {\n      var _a, _b;\n      const aState = getAtomState(a);\n      const dependents = new Set((_a = aState.m) == null ? void 0 : _a.t);\n      for (const atomWithPendingContinuablePromise of aState.p) {\n        dependents.add(atomWithPendingContinuablePromise);\n      }\n      (_b = getPendingDependents(pending, a)) == null ? void 0 : _b.forEach((dependent) => {\n        dependents.add(dependent);\n      });\n      return dependents;\n    };\n    const topsortedAtoms = [];\n    const markedAtoms = /* @__PURE__ */ new Set();\n    const visit = (n) => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\n    const isMarked = (a) => markedAtoms.has(a);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const aState = getAtomState(a);\n      const prevEpochNumber = aState.n;\n      let hasChangedDeps = false;\n      for (const dep of aState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        readAtomState(pending, a, isMarked);\n        mountDependencies(pending, a, aState);\n        if (prevEpochNumber !== aState.n) {\n          addPendingAtom(pending, a, aState);\n          changedAtoms.add(a);\n        }\n      }\n      markedAtoms.delete(a);\n    }\n  };\n  const writeAtomState = (pending, atom, ...args) => {\n    const getter = (a) => returnAtomValue(readAtomState(pending, a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const aState = getAtomState(a);\n        const hasPrevValue = \"v\" in aState;\n        const prevValue = aState.v;\n        const v = args2[0];\n        setAtomStateValueOrPromise(a, aState, v);\n        mountDependencies(pending, a, aState);\n        if (!hasPrevValue || !Object.is(prevValue, aState.v)) {\n          addPendingAtom(pending, a, aState);\n          recomputeDependents(pending, a);\n        }\n      } else {\n        r = writeAtomState(pending, a, ...args2);\n      }\n      flushPending(pending);\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const pending = createPending();\n    const result = writeAtomState(pending, atom, ...args);\n    flushPending(pending);\n    return result;\n  };\n  const mountDependencies = (pending, atom, atomState) => {\n    if (atomState.m && !getPendingContinuablePromise(atomState)) {\n      for (const a of atomState.d.keys()) {\n        if (!atomState.m.d.has(a)) {\n          const aMounted = mountAtom(pending, a);\n          aMounted.t.add(atom);\n          atomState.m.d.add(a);\n        }\n      }\n      for (const a of atomState.m.d || []) {\n        if (!atomState.d.has(a)) {\n          atomState.m.d.delete(a);\n          const aMounted = unmountAtom(pending, a);\n          aMounted == null ? void 0 : aMounted.t.delete(atom);\n        }\n      }\n    }\n  };\n  const mountAtom = (pending, atom) => {\n    const atomState = getAtomState(atom);\n    if (!atomState.m) {\n      readAtomState(pending, atom);\n      for (const a of atomState.d.keys()) {\n        const aMounted = mountAtom(pending, a);\n        aMounted.t.add(atom);\n      }\n      atomState.m = {\n        l: /* @__PURE__ */ new Set(),\n        d: new Set(atomState.d.keys()),\n        t: /* @__PURE__ */ new Set()\n      };\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        debugMountedAtoms.add(atom);\n      }\n      if (isActuallyWritableAtom(atom) && atom.onMount) {\n        const mounted = atomState.m;\n        const { onMount } = atom;\n        addPendingFunction(pending, () => {\n          const onUnmount = onMount(\n            (...args) => writeAtomState(pending, atom, ...args)\n          );\n          if (onUnmount) {\n            mounted.u = onUnmount;\n          }\n        });\n      }\n    }\n    return atomState.m;\n  };\n  const unmountAtom = (pending, atom) => {\n    const atomState = getAtomState(atom);\n    if (atomState.m && !atomState.m.l.size && !Array.from(atomState.m.t).some((a) => {\n      var _a;\n      return (_a = getAtomState(a).m) == null ? void 0 : _a.d.has(atom);\n    })) {\n      const onUnmount = atomState.m.u;\n      if (onUnmount) {\n        addPendingFunction(pending, onUnmount);\n      }\n      delete atomState.m;\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        debugMountedAtoms.delete(atom);\n      }\n      for (const a of atomState.d.keys()) {\n        const aMounted = unmountAtom(pending, a);\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\n      }\n      const pendingPromise = getPendingContinuablePromise(atomState);\n      if (pendingPromise) {\n        pendingPromise[CONTINUE_PROMISE](void 0, () => {\n        });\n      }\n      return void 0;\n    }\n    return atomState.m;\n  };\n  const subscribeAtom = (atom, listener) => {\n    const pending = createPending();\n    const mounted = mountAtom(pending, atom);\n    flushPending(pending);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      const pending2 = createPending();\n      unmountAtom(pending2, atom);\n      flushPending(pending2);\n    };\n  };\n  const store = {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    const devStore = {\n      // store dev methods (these are tentative and subject to change without notice)\n      dev4_get_internal_weak_map: () => atomStateMap,\n      dev4_get_mounted_atoms: () => debugMountedAtoms,\n      dev4_restore_atoms: (values) => {\n        const pending = createPending();\n        for (const [atom, value] of values) {\n          if (hasInitialValue(atom)) {\n            const atomState = getAtomState(atom);\n            const hasPrevValue = \"v\" in atomState;\n            const prevValue = atomState.v;\n            setAtomStateValueOrPromise(atom, atomState, value);\n            mountDependencies(pending, atom, atomState);\n            if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n              addPendingAtom(pending, atom, atomState);\n              recomputeDependents(pending, atom);\n            }\n          }\n        }\n        flushPending(pending);\n      }\n    };\n    Object.assign(store, devStore);\n  }\n  return store;\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n", "'use client';\nimport ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(\n  void 0\n);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromiseLike(value) ? use(value) : value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n"],
  "mappings": "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",
  "names": ["atom", "isPromiseLike", "ReactExports", "atom"]
}
